(function(i,m){typeof exports=="object"&&typeof module<"u"?m(exports):typeof define=="function"&&define.amd?define(["exports"],m):(i=typeof globalThis<"u"?globalThis:i||self,m(i.SpringEasing={}))})(this,function(i){"use strict";function m(e){const n=parseFloat(e);return typeof n=="number"&&!Number.isNaN(n)}function f(e,n,t){return Math.min(Math.max(e,n),t)}function y(e,n,t){return n+(t-n)*e}function E(e,n){return Math.round(e*10**n)/10**n}function b(e){const n=parseFloat(e);return e.toString().replace(n.toString(),"")}function z(e){return function(n,t,r){return n.map(s=>e(s,t,r))}}const l=(e,[n=1,t=100,r=10,s=0]=[],a)=>{if(e===0||e===1)return e;n=f(n,.1,1e3),t=f(t,.1,1e3),r=f(r,.1,1e3),s=f(s,.1,1e3);const u=Math.sqrt(t/n),o=r/(2*Math.sqrt(t*n)),c=o<1?u*Math.sqrt(1-o*o):0,g=1,F=o<1?(o*u+-s)/c:-s+u;let p=a?a*e/1e3:e;return o<1?p=Math.exp(-p*o*u)*(g*Math.cos(c*p)+F*Math.sin(c*p)):p=(g+F*p)*Math.exp(-p*u),1-p},d=new Map,w=1e5;function k([e,n,t,r]=[]){let s=[e,n,t,r],a=`${s}`;if(d.has(a))return d.get(a);const u=1/6;let o=0,c=0,g=0;for(;++g<w;)if(o+=u,l(o,s,null)===1){if(c++,c>=16)break}else c=0;const F=o*u*1e3;return d.set(a,F),F}function L(e){return(n,t=[],r)=>1-e(1-n,t,r)}function T(e){return function(n,t=[],r){return n<.5?e(n*2,t,r)/2:1-e(n*-2+2,t,r)/2}}function C(e){return function(n,t=[],r){return n<.5?(1-e(1-n*2,t,r))/2:(e(n*2-1,t,r)+1)/2}}const P=l,j=L(l),q=T(l),A=C(l);function S(e,n,t=3){const r=n.length-1,s=f(Math.floor(e*r),0,r-1),a=n[s],u=n[s+1],o=(e-s/r)*r;return E(y(o,a,u),t)}function O(e,n,t=3){const r=n.length-1;return e.map(s=>{const a=f(Math.floor(s*r),0,r-1),u=n[a],o=n[a+1],c=(s-a/r)*r;return E(y(c,u,o),t)})}function I(e,n){const t=n.length-1;e=f(e,0,1);const r=Math.round(e*t);return n[r]}function N(e,n){const t=n.length-1;return e.map(r=>{r=f(r,0,1);const s=Math.round(r*t);return n[s]})}const B=I,W=N;function U(e,n,t=3){let r="";return m(n[0])&&(r=b(n[0])),S(e,n.map(s=>typeof s=="number"?s:parseFloat(s)),t)+r}function $(e,n,t=3){let r="";return m(n[0])&&(r=b(n[0])),O(e,n.map(s=>typeof s=="number"?s:parseFloat(s)),t).map(s=>s+r)}function Y(e,n,t=3){return n.every(a=>typeof a=="number")?S(e,n,t):n.every(a=>m(a))?U(e,n,t):I(e,n)}function D(e,n,t=3){return n.every(a=>typeof a=="number")?O(e,n,t):n.every(a=>m(a))?$(e,n,t):N(e,n)}i.EasingFunctions={spring:l,"spring-in":P,"spring-out":j,"spring-in-out":q,"spring-out-in":A},i.EasingFunctionKeys=Object.keys(i.EasingFunctions);function H(e,n){i.EasingFunctions={...i.EasingFunctions,[e]:n},i.EasingFunctionKeys=Object.keys(i.EasingFunctions)}function J(e){i.EasingFunctions={...i.EasingFunctions,...e},i.EasingFunctionKeys=Object.keys(i.EasingFunctions)}function _(e){const n=/(\(|\s)([^)]+)\)?/.exec(e.toString());return n?n[2].split(",").map(t=>{let r=parseFloat(t);return Number.isNaN(r)?t.trim():r}):[]}function M(e={}){const n=typeof e=="string"||Array.isArray(e)&&typeof e[0]=="function";let{easing:t=[l,1,100,10,0],numPoints:r=100,decimal:s=3}=n?{easing:e}:e;if(typeof t=="string"){const a=i.EasingFunctions[t.replace(/(\(|\s).+/,"").toLowerCase().trim()],u=_(t);t=[a,...u]}return{easing:t,numPoints:r,decimal:s}}const h=new Map;function K(e={}){let{easing:n,numPoints:t}=M(e);if(Array.isArray(n)){if(typeof n[0]!="function")throw new Error("[spring-easing] A frame function is required as the first element in the easing array, e.g. [SpringFrame, ...]");n.length>1&&n.length<5&&console.warn(`[spring-easing] Be careful of only setting some of the spring parameters, you've only set ${5-n.length} spring parameter(s). The easing works best in the format: 
* "spring-out(mass, stiffness, damping, velocity)" or 
* [SpringOutFrame, mass, stiffness, damping, velocity].`),n.length>5&&console.warn(`[spring-easing] You entered ${5-n.length} more spring parameter(s) than necessary. The easing needs to be in the format: 
* "spring-out(mass, stiffness, damping, velocity)" or 
* [SpringOutFrame, mass, stiffness, damping, velocity].`)}else throw new Error(`[spring-easing] The easing needs to be in the format:  
* "spring-out(mass, stiffness, damping, velocity)" or 
* [SpringOutFrame, mass, stiffness, damping, velocity], the easing recieved is "${n}", [spring-easing] doesn't really know what to do with that.`);let[r,...s]=n;const a=`${s},${t}`;if(h.has(a)){let g=h.get(a);if(g.has(r))return g.get(r)}const u=[],o=k(s);for(let g=0;g<t;g++)u[g]=r(g/(t-1),s,o);const c=h.has(a)?h.get(a):new WeakMap;return c.set(r,[u,o]),h.set(a,c),[u,o]}function G(e,n={},t=D){const r=M(n),[s,a]=K(r);return[t(s,e,r.decimal),a]}i.EaseInOut=T,i.EaseOut=L,i.EaseOutIn=C,i.EasingDurationCache=d,i.EasingOptions=M,i.FramePtsCache=h,i.GenerateSpringFrames=K,i.INFINITE_LOOP_LIMIT=w,i.SpringEasing=G,i.SpringFrame=l,i.SpringInFrame=P,i.SpringInOutFrame=q,i.SpringOutFrame=j,i.SpringOutInFrame=A,i.default=G,i.getSpringDuration=k,i.getUnit=b,i.instantComplex=Y,i.instantNumber=S,i.instantSequence=I,i.instantString=U,i.instantUsingIndex=B,i.interpolateComplex=D,i.interpolateNumber=O,i.interpolateSequence=N,i.interpolateString=$,i.interpolateUsingIndex=W,i.isNumberLike=m,i.limit=f,i.parseEasingParameters=_,i.registerEasingFunction=H,i.registerEasingFunctions=J,i.scale=y,i.toAnimationFrames=z,i.toFixed=E,Object.defineProperties(i,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
