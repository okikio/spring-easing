"use strict";Object.defineProperties(exports,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}});function h(t){const n=parseFloat(t);return typeof n=="number"&&!Number.isNaN(n)}function g(t,n,e){return Math.min(Math.max(t,n),e)}function E(t,n,e){return n+(e-n)*t}function b(t,n){return Math.round(t*10**n)/10**n}function y(t){const n=parseFloat(t);return t.toString().replace(n.toString(),"")}function K(t){return function(n,e,r){return n.map(i=>t(i,e,r))}}const m=(t,[n=1,e=100,r=10,i=0]=[],s)=>{if(t===0||t===1)return t;n=g(n,.1,1e3),e=g(e,.1,1e3),r=g(r,.1,1e3),i=g(i,.1,1e3);const a=Math.sqrt(e/n),o=r/(2*Math.sqrt(e*n)),u=o<1?a*Math.sqrt(1-o*o):0,c=1,l=o<1?(o*a+-i)/u:-i+a;let p=s?s*t/1e3:t;return o<1?p=Math.exp(-p*o*a)*(c*Math.cos(u*p)+l*Math.sin(u*p)):p=(c+l*p)*Math.exp(-p*a),1-p},F=new Map,M=1e5;function w([t,n,e,r]=[]){let i=[t,n,e,r],s=`${i}`;if(F.has(s))return F.get(s);const a=1/6;let o=0,u=0,c=0;for(;++c<M;)if(o+=a,m(o,i,null)===1){if(u++,u>=16)break}else u=0;const l=o*a*1e3;return F.set(s,l),l}function k(t){return(n,e=[],r)=>1-t(1-n,e,r)}function x(t){return function(n,e=[],r){return n<.5?t(n*2,e,r)/2:1-t(n*-2+2,e,r)/2}}function L(t){return function(n,e=[],r){return n<.5?(1-t(1-n*2,e,r))/2:(t(n*2-1,e,r)+1)/2}}const C=m,P=k(m),q=x(m),T=L(m);function S(t,n,e=3){const r=n.length-1,i=g(Math.floor(t*r),0,r-1),s=n[i],a=n[i+1],o=(t-i/r)*r;return b(E(o,s,a),e)}function O(t,n,e=3){const r=n.length-1;return t.map(i=>{const s=g(Math.floor(i*r),0,r-1),a=n[s],o=n[s+1],u=(i-s/r)*r;return b(E(u,a,o),e)})}function d(t,n){const e=n.length-1;t=g(t,0,1);const r=Math.round(t*e);return n[r]}function I(t,n){const e=n.length-1;return t.map(r=>{r=g(r,0,1);const i=Math.round(r*e);return n[i]})}const G=d,z=I;function j(t,n,e=3){let r="";return h(n[0])&&(r=y(n[0])),S(t,n.map(i=>typeof i=="number"?i:parseFloat(i)),e)+r}function A(t,n,e=3){let r="";return h(n[0])&&(r=y(n[0])),O(t,n.map(i=>typeof i=="number"?i:parseFloat(i)),e).map(i=>i+r)}function B(t,n,e=3){return n.every(s=>typeof s=="number")?S(t,n,e):n.every(s=>h(s))?j(t,n,e):d(t,n)}function U(t,n,e=3){return n.every(s=>typeof s=="number")?O(t,n,e):n.every(s=>h(s))?A(t,n,e):I(t,n)}exports.EasingFunctions={spring:m,"spring-in":C,"spring-out":P,"spring-in-out":q,"spring-out-in":T};exports.EasingFunctionKeys=Object.keys(exports.EasingFunctions);function W(t,n){exports.EasingFunctions={...exports.EasingFunctions,[t]:n},exports.EasingFunctionKeys=Object.keys(exports.EasingFunctions)}function Y(t){exports.EasingFunctions={...exports.EasingFunctions,...t},exports.EasingFunctionKeys=Object.keys(exports.EasingFunctions)}function $(t){const n=/(\(|\s)([^)]+)\)?/.exec(t.toString());return n?n[2].split(",").map(e=>{let r=parseFloat(e);return Number.isNaN(r)?e.trim():r}):[]}function N(t={}){const n=typeof t=="string"||Array.isArray(t)&&typeof t[0]=="function";let{easing:e=[m,1,100,10,0],numPoints:r=100,decimal:i=3}=n?{easing:t}:t;if(typeof e=="string"){const s=exports.EasingFunctions[e.replace(/(\(|\s).+/,"").toLowerCase().trim()],a=$(e);e=[s,...a]}return{easing:e,numPoints:r,decimal:i}}const f=new Map;function D(t={}){let{easing:n,numPoints:e}=N(t);if(Array.isArray(n)){if(typeof n[0]!="function")throw new Error("[spring-easing] A frame function is required as the first element in the easing array, e.g. [SpringFrame, ...]");n.length>1&&n.length<5&&console.warn(`[spring-easing] Be careful of only setting some of the spring parameters, you've only set ${5-n.length} spring parameter(s). The easing works best in the format: 
* "spring-out(mass, stiffness, damping, velocity)" or 
* [SpringOutFrame, mass, stiffness, damping, velocity].`),n.length>5&&console.warn(`[spring-easing] You entered ${5-n.length} more spring parameter(s) than necessary. The easing needs to be in the format: 
* "spring-out(mass, stiffness, damping, velocity)" or 
* [SpringOutFrame, mass, stiffness, damping, velocity].`)}else throw new Error(`[spring-easing] The easing needs to be in the format:  
* "spring-out(mass, stiffness, damping, velocity)" or 
* [SpringOutFrame, mass, stiffness, damping, velocity], the easing recieved is "${n}", [spring-easing] doesn't really know what to do with that.`);let[r,...i]=n;const s=`${i},${e}`;if(f.has(s)){let c=f.get(s);if(c.has(r))return c.get(r)}const a=[],o=w(i);for(let c=0;c<e;c++)a[c]=r(c/(e-1),i,o);const u=f.has(s)?f.get(s):new WeakMap;return u.set(r,[a,o]),f.set(s,u),[a,o]}function _(t,n={},e=U){const r=N(n),[i,s]=D(r);return[e(i,t,r.decimal),s]}exports.EaseInOut=x;exports.EaseOut=k;exports.EaseOutIn=L;exports.EasingDurationCache=F;exports.EasingOptions=N;exports.FramePtsCache=f;exports.GenerateSpringFrames=D;exports.INFINITE_LOOP_LIMIT=M;exports.SpringEasing=_;exports.SpringFrame=m;exports.SpringInFrame=C;exports.SpringInOutFrame=q;exports.SpringOutFrame=P;exports.SpringOutInFrame=T;exports.default=_;exports.getSpringDuration=w;exports.getUnit=y;exports.instantComplex=B;exports.instantNumber=S;exports.instantSequence=d;exports.instantString=j;exports.instantUsingIndex=G;exports.interpolateComplex=U;exports.interpolateNumber=O;exports.interpolateSequence=I;exports.interpolateString=A;exports.interpolateUsingIndex=z;exports.isNumberLike=h;exports.limit=g;exports.parseEasingParameters=$;exports.registerEasingFunction=W;exports.registerEasingFunctions=Y;exports.scale=E;exports.toAnimationFrames=K;exports.toFixed=b;
